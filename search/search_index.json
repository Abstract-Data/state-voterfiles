{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Abstract Data  State Voter File Reader &amp; Validator","text":""},{"location":"#features","title":"Features","text":"<ul> <li><code>class TomlReader</code> - Read state column fields into Python</li> <li><code>class VoterInfo</code> - Map column fields to class for reference</li> <li><code>class VoterFileLoader</code> - Load a state voter file</li> </ul>"},{"location":"#example","title":"Example","text":""},{"location":"#project-layout","title":"Project layout","text":"<pre><code>main  ...\nfuncs/\n    column_formats.py # Where `VoterInfo` class object is nested\nutils/ \n    csv_loader.py # CSV file reader\n    toml_reader.py # Toml file reader\nstate_fields/\n    ohio-fields.toml # Ohio voter file fields\n    texas-fields.toml # Texas voter file fields\n</code></pre>"},{"location":"funcs/csv_reader/","title":"csv_reader()","text":""},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.clean_and_read_csv","title":"<code>clean_and_read_csv(file_path, delimiter=',', **csv_kwargs)</code>","text":"<p>Cleans and reads a CSV file, replacing null bytes and yielding each row as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>delimiter</code> <code>str</code> <p>The delimiter used in the CSV file. Defaults to ','.</p> <code>','</code> <code>**csv_kwargs</code> <p>Additional keyword arguments for the CSV reader.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Each row in the CSV file as a dictionary.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def clean_and_read_csv(file_path: Path, delimiter=',', **csv_kwargs) -&gt; Generator[Dict[str, Any], None, None]:\n    \"\"\"\n    Cleans and reads a CSV file, replacing null bytes and yielding each row as a dictionary.\n\n    Args:\n        file_path (Path): The path to the CSV file.\n        delimiter (str, optional): The delimiter used in the CSV file. Defaults to ','.\n        **csv_kwargs: Additional keyword arguments for the CSV reader.\n\n    Yields:\n        Dict[str, Any]: Each row in the CSV file as a dictionary.\n    \"\"\"\n    with open(file_path, 'rb') as file:\n        content = file.read().replace(b'\\x00', b'')\n    cleaned_content = StringIO(content.decode(csv_kwargs.get(\"encoding\", \"utf-8\")))\n    reader = csv.DictReader(cleaned_content, delimiter=delimiter, **csv_kwargs)\n    for row in reader:\n        yield row\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.clean_filename","title":"<code>clean_filename(filename, max_length=63)</code>","text":"<p>Cleans and truncates a filename to ensure it contains only ASCII characters and is within a specified length.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The original filename to be cleaned.</p> required <code>max_length</code> <code>int</code> <p>The maximum length of the cleaned filename. Defaults to 63.</p> <code>63</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The cleaned and truncated filename.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def clean_filename(filename: str, max_length: int = 63) -&gt; str:\n    \"\"\"\n    Cleans and truncates a filename to ensure it contains only ASCII characters and is within a specified length.\n\n    Args:\n        filename (str): The original filename to be cleaned.\n        max_length (int, optional): The maximum length of the cleaned filename. Defaults to 63.\n\n    Returns:\n        str: The cleaned and truncated filename.\n    \"\"\"\n    filename = ''.join(char for char in filename if char in string.ascii_letters + string.digits)\n    return filename[:max_length]\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.detect_delimiter","title":"<code>detect_delimiter(file_path, num_lines=10)</code>","text":"<p>Detects the delimiter used in a CSV file by analyzing a specified number of lines.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>num_lines</code> <code>int</code> <p>The number of lines to analyze for delimiter detection. Defaults to 10.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The detected delimiter.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def detect_delimiter(file_path: Path, num_lines: int = 10) -&gt; str:\n    \"\"\"\n    Detects the delimiter used in a CSV file by analyzing a specified number of lines.\n\n    Args:\n        file_path (Path): The path to the CSV file.\n        num_lines (int, optional): The number of lines to analyze for delimiter detection. Defaults to 10.\n\n    Returns:\n        str: The detected delimiter.\n    \"\"\"\n    ic.configureOutput(prefix='detect_delimiter()|')\n    common_delimiters = [',', '\\t', ';', '|']\n    delimiter_counts = {delimiter: 0 for delimiter in common_delimiters}\n\n    # Detect the file encoding first\n    file_encoding = detect_file_encoding(file_path)\n\n    with open(file_path, 'r', encoding=file_encoding) as file:\n        lines = [file.readline() for _ in range(num_lines)]\n\n    for line in lines:\n        line_counts = Counter(line)\n        for delimiter in common_delimiters:\n            delimiter_counts[delimiter] += line_counts[delimiter]\n\n    detected_delimiter = max(delimiter_counts, key=delimiter_counts.get)\n    ic(f\"Detected delimiter for {file_path.name}: {detected_delimiter}\")\n    return detected_delimiter\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.detect_file_encoding","title":"<code>detect_file_encoding(file)</code>","text":"<p>Detects the encoding of a given file by reading its content in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the file whose encoding is to be detected.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The detected encoding of the file.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def detect_file_encoding(file: Path):\n    \"\"\"\n    Detects the encoding of a given file by reading its content in chunks.\n\n    Args:\n        file (Path): The path to the file whose encoding is to be detected.\n\n    Returns:\n        str: The detected encoding of the file.\n    \"\"\"\n    ic.configureOutput(prefix='detect_file_encoding()|')\n    _multiplier = 1\n    confidence = 0\n    _file_size_mb = file.stat().st_size / 1024 / 1024\n    read_size = 65536 * 5  # Initial read size of 64KB\n    total_read = 0\n\n    with open(file, 'rb') as f:\n        while confidence &lt; 1.0 and total_read &lt; _file_size_mb * 1024 * 1024:\n            sample = f.read(read_size)\n            total_read += len(sample)\n            if not sample:  # Break if end of file is reached\n                break\n            result = chardet.detect(sample)\n            confidence = result['confidence']\n            ic(f\"File:  {file.name} \\r\"\n               f\"Detected encoding: {result['encoding']} \\r\"\n               f\"Confidence level:  {confidence:.2%}. \\r\"\n               f\"File size read:    {total_read / 1024 / 1024:.2f} MB. ({total_read / (_file_size_mb * 1024 * 1024):.2%}) \\r\"\n               f\"Continuing to analyze the file.\")\n            read_size *= _multiplier  # Increase read size for the next iteration\n            _multiplier *= 10  # Exponentially increase the multiplier\n\n        ic(f\"Detected encoding: {result['encoding']}\")\n    return result['encoding']\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.include_file_date_created","title":"<code>include_file_date_created(func)</code>","text":"<p>Decorator that adds the file creation date to each record yielded by the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be decorated.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The decorated function.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def include_file_date_created(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator that adds the file creation date to each record yielded by the decorated function.\n\n    Args:\n        func (Callable): The function to be decorated.\n\n    Returns:\n        Callable: The decorated function.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        records = func(*args, **kwargs)\n        for record in records:\n            record[\"created_at\"] = Path(args[0]).stat().st_ctime\n            yield record\n    return wrapper\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.include_file_date_imported","title":"<code>include_file_date_imported(func)</code>","text":"<p>Decorator that adds the file import date to each record yielded by the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be decorated.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The decorated function.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def include_file_date_imported(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator that adds the file import date to each record yielded by the decorated function.\n\n    Args:\n        func (Callable): The function to be decorated.\n\n    Returns:\n        Callable: The decorated function.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        records = func(*args, **kwargs)\n        for record in records:\n            record[\"imported_at\"] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n            yield record\n    return wrapper\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.include_file_origin","title":"<code>include_file_origin(func)</code>","text":"<p>Decorator that adds the file origin to each record yielded by the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be decorated.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The decorated function.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def include_file_origin(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator that adds the file origin to each record yielded by the decorated function.\n\n    Args:\n        func (Callable): The function to be decorated.\n\n    Returns:\n        Callable: The decorated function.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        records = func(*args, **kwargs)\n        for record in records:\n            record[\"file_origin\"] = Path(args[0]).stem\n            yield record\n    return wrapper\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.read_csv","title":"<code>read_csv(file, **kwargs)</code>","text":"<pre><code>read_csv(file: str, **kwargs)\n</code></pre><pre><code>read_csv(file: Path, **kwargs)\n</code></pre> <p>Reads a CSV file and yields each row as a dictionary, with additional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>The path to the CSV file.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the CSV reader.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Each row in the CSV file as a dictionary with additional metadata.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>@include_file_origin\n@include_file_date_created\n@include_file_date_imported\ndef read_csv(file: Union[str, Path], **kwargs) -&gt; Generator[Dict[str, Any], None, None]:\n    \"\"\"\n    Reads a CSV file and yields each row as a dictionary, with additional metadata.\n\n    Args:\n        file (Union[str, Path]): The path to the CSV file.\n        **kwargs: Additional keyword arguments for the CSV reader.\n\n    Yields:\n        Dict[str, Any]: Each row in the CSV file as a dictionary with additional metadata.\n    \"\"\"\n    ic.configureOutput(prefix='read_csv()|')\n    if isinstance(file, str):\n        file = Path(file)\n\n    # _log = logfire.span(f\"Reading {file.name}\")\n    _encoding = kwargs.get(\"encoding\", detect_file_encoding(file))\n    _delim = kwargs.get(\"delimiter\", detect_delimiter(file))\n    _headers = kwargs.get(\"headers\", None)\n    _uppercase = kwargs.get(\"uppercase\", False)\n    _lowercase = kwargs.get(\"lowercase\", False)\n    _state = kwargs.get(\"state\", None)\n    # with _log:\n    with open(file, \"r\", encoding=_encoding if _encoding != \"ascii\" else \"utf-8\", errors='ignore') as f:\n        if file.suffix == \".txt\":\n            if _headers:\n                reader = csv.DictReader(f, delimiter=_delim, fieldnames=_headers)\n            else:\n                reader = csv.DictReader(f, delimiter=_delim)\n                first_row_header = next(reader)\n                try:\n                    reader = csv.DictReader(f, delimiter=_delim, fieldnames=first_row_header)\n                except csv.Error:\n                    reader = clean_and_read_csv(\n                        file,\n                        delimiter=_delim,\n                        fieldnames=first_row_header,\n                        encoding=_encoding\n                    )\n        elif file.suffix == \".csv\":\n            try:\n                reader = csv.DictReader(f)\n            except csv.Error:\n                reader = clean_and_read_csv(\n                    file,\n                    delimiter=_delim\n                )\n        else:\n            reader = None\n\n        if reader:\n            _counter = 0\n            for record in reader:\n                record = {k: (v if v != '' else None) for k, v in record.items()}\n                record = {k: v.upper() for k, v in record.items() if k and v}\n                if _uppercase:\n                    record = {k.upper(): v for k, v in record.items() if k and v}\n                elif _lowercase:\n                    record = {k.lower(): v for k, v in record.items() if k and v}\n                if _state:\n                    record[\"state\"] = _state\n                _counter += 1\n                yield record\n</code></pre>"},{"location":"funcs/csv_reader/#state_voterfiles.utils.readers.csv_reader.replace_empty_with_none","title":"<code>replace_empty_with_none(record)</code>","text":"<p>Replaces empty string values in a dictionary with None.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>Dict[str, Any]</code> <p>The dictionary to be processed.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The processed dictionary with empty strings replaced by None.</p> Source code in <code>state_voterfiles/utils/readers/csv_reader.py</code> <pre><code>def replace_empty_with_none(record: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Replaces empty string values in a dictionary with None.\n\n    Args:\n        record (Dict[str, Any]): The dictionary to be processed.\n\n    Returns:\n        Dict[str, Any]: The processed dictionary with empty strings replaced by None.\n    \"\"\"\n    reader = csv.DictReader(f, delimiter=_delim, fieldnames=first_row_header)\n    return {k: (v if v != '' else None) for k, v in record.items()}\n</code></pre>"},{"location":"funcs/toml_reader_doc/","title":"TOML File Reader","text":"<p>A class used to read and process TOML files.</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>Path</code> <p>The path to the TOML file.</p> <code>name</code> <code>str</code> <p>The name of the TOML file. Defaults to None.</p> <code>_data</code> <code>Dict</code> <p>The data from the TOML file. Defaults to None.</p> Properties <p>data (Dict): Returns the data from the TOML file. Can also set the data.</p> <p>Methods:</p> Name Description <code>replace_null_with_none</code> <p>Replaces all instances of \"null\" in the data with None.</p> Source code in <code>state_voterfiles/utils/readers/toml_reader.py</code> <pre><code>@dataclass\nclass TomlReader:\n    \"\"\"\n    A class used to read and process TOML files.\n\n    Attributes:\n        file (Path): The path to the TOML file.\n        name (str, optional): The name of the TOML file. Defaults to None.\n        _data (Dict, optional): The data from the TOML file. Defaults to None.\n\n    Properties:\n        data (Dict): Returns the data from the TOML file. Can also set the data.\n\n    Methods:\n        replace_null_with_none(data): Replaces all instances of \"null\" in the data with None.\n    \"\"\"\n    file: Path\n    name: str = None\n    _data: Dict = None\n\n    def __repr__(self):\n        return f\"{self.file.name}\" if not self.name else f\"{self.name} TOML file\"\n\n    @property\n    def data(self) -&gt; Dict:\n        with open(self.file, \"rb\") as f:\n            self._data = tomli.load(f)\n        return self._data\n\n    @data.setter\n    def data(self, value):\n        self._data = value\n\n    def replace_null_with_none(self, data):\n        def replace_null(item):\n            if isinstance(item, dict):\n                return {k: replace_null(v) for k, v in item.items()}\n            elif isinstance(item, list):\n                return [replace_null(v) for v in item]\n            elif item == \"null\":\n                return None\n            else:\n                return item\n\n        self.data = replace_null(data)\n        return self.data\n\n    def __post_init__(self):\n        # self.load()\n        # Replace all values that are \"null\" with None\n        self.data = self.replace_null_with_none(self.data)\n</code></pre>"},{"location":"funcs/voter_info_doc/","title":"Voter info doc","text":""},{"location":"funcs/voter_info_doc/#voter-info-class-documentation","title":"Voter Info Class Documentation","text":"<p>This module provides a <code>VoterInfo</code> class, which is used to parse a state's TOML file, turning each column into reference variables.</p>"},{"location":"funcs/voter_info_doc/#usage","title":"Usage","text":"<p>First, import the <code>VoterInfo</code> class: <pre><code>from voter_info import VoterInfo\n</code></pre></p> <p>Next, create an instance of the <code>VoterInfo</code> class by passing in the path to the TOML file for the state you are interested in: <pre><code>vi = VoterInfo('/path/to/state-toml-file.toml')\n</code></pre></p> <p>You can then access the voter information for a given voter using the reference variables generated by the <code>VoterInfo</code> class: <pre><code>voter_info = vi.get_voter_info(vuid)\n</code></pre></p> <p>Here, vuid is the unique identifier for the voter you are interested in. The <code>get_voter_info</code> method returns a dictionary containing the voter's information.</p> <p></p>"},{"location":"funcs/voter_info_doc/#voterinfo-class","title":"VoterInfo class","text":""},{"location":"funcs/voter_info_doc/#class-variables","title":"Class Variables","text":"<p><code>column_map</code>: a ClassVar dictionary that maps TOML columns to reference variables.</p> <p><code>address_parts</code>: a ClassVar dictionary that maps address parts to reference variables. </p>"},{"location":"funcs/voter_info_doc/#instance-variables","title":"Instance Variables","text":"<p><code>state</code>: the state abbreviation.</p> <p><code>data</code>: a dictionary containing the parsed TOML data.</p> <p><code>elections</code>: a dictionary containing information about the state's elections. </p>"},{"location":"funcs/voter_info_doc/#methods","title":"Methods","text":"<p><code>__init__(self, file_path: Union[str, Path])</code>: Initializes the VoterInfo class by parsing the TOML file at the given file_path.</p> <p><code>get_voter_info(self, vuid: str) -&gt; dict</code>: Returns a dictionary containing the voter information for the voter with the given vuid.</p> <p><code>__getattribute__(self, item: str)</code>: Overrides the default getattribute method to provide access to the reference variables generated by the VoterInfo class. </p>"},{"location":"funcs/voter_info_doc/#example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom voter_info import VoterInfo\n\nvi = VoterInfo(Path('/path/to/state-toml-file.toml'))\n\nvoter_info = vi.get_voter_info('voter_id')\nlast_name = vi.LNAME\nfirst_name = vi.FNAME\naddress1 = vi.RESIDENTIAL_ADDRESS1\ncity = vi.RESIDENTIAL_CITY\nstate = vi.RESIDENTIAL_STATE\nzip_code = vi.RESIDENTIAL_ZIP\n</code></pre> <p>Here, <code>voter_info</code> is a dictionary containing the voter's information. The remaining variables are reference variables generated by the <code>VoterInfo</code> class that correspond to columns in the TOML file.</p>"},{"location":"state-fields/ohio-fields/","title":"Ohio Fields","text":""},{"location":"state-fields/ohio-fields/#overview","title":"Overview","text":"<p>Below are the fields that are available for Ohio.  The fields are grouped by the section of the voter file they are in.</p>"},{"location":"state-fields/ohio-fields/#ohio-toml-voter-file-fields","title":"Ohio TOML Voter File Fields","text":"<pre><code>[PERSON-DETAILS]\n    [PERSON-DETAILS.voter-info]\n        vuid = 'SOS_VOTERID'\n        registration_date = 'REGISTRATION_DATE'\n        registration_status = 'VOTER_STATUS'\n        political_party = 'PARTY_AFFILIATION'\n        dob = 'DATE_OF_BIRTH'\n    [PERSON-DETAILS.name]\n        last = 'LAST_NAME'\n        first= 'FIRST_NAME'\n        middle = 'MIDDLE_NAME'\n        suffix = 'SUFFIX'\n        [PERSON-DETAILS.ADDRESS]\n            [PERSON-DETAILS.ADDRESS.residence]\n                address1 = 'RESIDENTIAL_ADDRESS1'\n                address2 = 'RESIDENTIAL_SECONDARY_ADDR'\n                city = 'RESIDENTIAL_CITY'\n                state = 'RESIDENTIAL_STATE'\n                zip5 = 'RESIDENTIAL_ZIP'\n                zip4 = 'RESIDENTIAL_ZIP_PLUS4'\n                country = 'RESIDENTIAL_COUNTRY'\n                postal_code = 'RESIDENTIAL_POSTALCODE'\n            [PERSON-DETAILS.ADDRESS.parts.residence]\n                house_number = 'RHNUM'\n                house_direction = 'RDESIG'\n                street_name = 'RSTNAME'\n                street_type = 'RSTTYPE'\n                street_suffix = 'RSTSFX'\n                unit_number = 'RUNUM'\n                unit_type = 'RUTYPE'\n                city = 'RCITY'\n                state = 'TX'\n                zip = 'RZIP'\n                zip4 = ''\n            [PERSON-DETAILS.ADDRESS.mail]\n                address1 = 'MAILING_ADDRESS1'\n                address2 = 'MAILING_SECONDARY_ADDRESS'\n                city = 'MAILING_CITY'\n                state = 'MAILING_STATE'\n                zip5 = 'MAILING_ZIP'\n                zip4 = 'MAILING_ZIP_PLUS4'\n                country = 'MAILING_COUNTRY'\n                postal_code = 'MAILING_POSTAL_CODE'\n        [PERSON-DETAILS.VOTING-DISTRICTS]\n            municipal_court_district = 'MUNICIPAL_COURT_DISTRICT'\n            court_of_appeals = 'COURT_OF_APPEALS'\n            local_school_district = 'LOCAL_SCHOOL_DISTRICT'\n                [PERSON-DETAILS.VOTING-DISTRICTS.precinct]\n                    name = 'PRECINCT_NAME'\n                    code = 'PRECINCT_CODE'\n                [PERSON-DETAILS.VOTING-DISTRICTS.city]\n                    name = 'CITY'\n                    school_district = 'CITY_SCHOOL_DISTRICT'\n\n                [PERSON-DETAILS.VOTING-DISTRICTS.county]\n                    number = 'COUNTY_NUMBER'\n                    id = 'COUNTY_ID'\n                    township = 'TOWNSHIP'\n                    village = 'VILLAGE'\n                    ward = 'WARD'\n                    library_district = 'LIBRARY'\n                    career_center = 'CAREER_CENTER'\n                    court_district = 'COUNTY_COURT_DISTRICT'\n                    education_service_center = 'EDU_SERVICE_CENTER_DISTRICT'\n                    exempted_village_school_district = 'EXEMPTED_VILL_SCHOOL_DISTRICT'\n                [PERSON-DETAILS.VOTING-DISTRICTS.state]\n                    board_of_edu = 'STATE_BOARD_OF_EDUCATION'\n                    lower_chamber = 'STATE_REPRESENTATIVE_DISTRICT'\n                    upper_chamber = 'STATE_SENATE_DISTRICT'\n                [PERSON-DETAILS.VOTING-DISTRICTS.federal]\n                    congressional = 'CONGRESSIONAL_DISTRICT'\n\n[ELECTION-DATES]\n    [ELECTION-DATES.Y2000]\n        primary.march = ['PRIMARY-03/07/2000']\n        general.november = ['GENERAL-11/07/2000']\n    [ELECTION-DATES.Y2001]\n        special.may = ['SPECIAL-05/08/2001']\n        general.november = ['GENERAL-11/06/2001']\n    [ELECTION-DATES.Y2002]\n        primary.may = ['PRIMARY-05/07/2002']\n        general.november = ['GENERAL-11/05/2002']\n    [ELECTION-DATES.Y2003]\n        special.may = ['SPECIAL-05/06/2003']\n        general.november = ['GENERAL-11/04/2003']\n    [ELECTION-DATES.Y2004]\n        primary.march = ['PRIMARY-03/02/2004']\n        general.november = ['GENERAL-11/02/2004']\n    [ELECTION-DATES.Y2005]\n        special.february = ['SPECIAL-02/08/2005']\n        primary.may = ['PRIMARY-05/03/2005']\n        primary.september = ['PRIMARY-09/13/2005']\n        general.november = ['GENERAL-11/08/2005']\n    [ELECTION-DATES.Y2006]\n        special.february = ['SPECIAL-02/07/2006']\n        primary.may = ['PRIMARY-05/02/2006']\n        general.november = ['GENERAL-11/07/2006']\n    [ELECTION-DATES.Y2007]\n        primary.may = ['PRIMARY-05/08/2007']\n        primary.september = ['PRIMARY-09/11/2007']\n        general.november = ['GENERAL-11/06/2007']\n        primary.november = ['PRIMARY-11/06/2007']\n        general.december = ['GENERAL-12/11/2007']\n    [ELECTION-DATES.Y2008]\n        primary.march = ['PRIMARY-03/04/2008']\n        primary.october = ['PRIMARY-10/14/2008']\n        general.november = ['GENERAL-11/04/2008', 'GENERAL-11/18/2008']\n    [ELECTION-DATES.Y2009]\n        primary.may = ['PRIMARY-05/05/2009']\n        primary.september = ['PRIMARY-09/08/2009', 'PRIMARY-09/15/2009', 'PRIMARY-09/29/2009']\n        general.november = ['GENERAL-11/03/2009']\n    [ELECTION-DATES.Y2010]\n        primary.may = ['PRIMARY-05/04/2010']\n        primary.july = ['PRIMARY-07/13/2010']\n        primary.september = ['PRIMARY-09/07/2010']\n        general.november = ['GENERAL-11/02/2010']\n    [ELECTION-DATES.Y2011]\n        primary.may = ['PRIMARY-05/03/2011']\n        primary.september = ['PRIMARY-09/13/2011']\n        general.november = ['GENERAL-11/08/2011']\n    [ELECTION-DATES.Y2012]\n        primary.march = ['PRIMARY-03/06/2012']\n        general.november = ['GENERAL-11/06/2012']\n    [ELECTION-DATES.Y2013]\n        primary.may = ['PRIMARY-05/07/2013']\n        primary.september = ['PRIMARY-09/10/2013']\n        primary.october = ['PRIMARY-10/01/2013']\n        general.november = ['GENERAL-11/05/2013']\n    [ELECTION-DATES.Y2014]\n        primary.may = ['PRIMARY-05/06/2014']\n        general.november = ['GENERAL-11/04/2014']\n    [ELECTION-DATES.Y2015]\n        primary.may = ['PRIMARY-05/05/2015']\n        primary.september = ['PRIMARY-09/15/2015']\n        general.november = ['GENERAL-11/03/2015']\n    [ELECTION-DATES.Y2016]\n        primary.march = ['PRIMARY-03/15/2016']\n        general.june = ['GENERAL-06/07/2016']\n        primary.september = ['PRIMARY-09/13/2016']\n        general.november = ['GENERAL-11/08/2016']\n    [ELECTION-DATES.Y2017]\n        primary.may = ['PRIMARY-05/02/2017']\n        primary.september = ['PRIMARY-09/12/2017']\n        general.november = ['GENERAL-11/07/2017']\n    [ELECTION-DATES.Y2018]\n        primary.may = ['PRIMARY-05/08/2018']\n        general.august = ['GENERAL-08/07/2018']\n        general.november = ['GENERAL-11/06/2018']\n    [ELECTION-DATES.Y2019]\n        primary.may = ['PRIMARY-05/07/2019']\n        primary.september = ['PRIMARY-09/10/2019']\n        general.november = ['GENERAL-11/05/2019']\n    [ELECTION-DATES.Y2020]\n        primary.march = ['PRIMARY-03/17/2020']\n        general.november = ['GENERAL-11/03/2020']\n    [ELECTION-DATES.Y2021]\n        primary.may = ['PRIMARY-05/04/2021']\n        primary.august = ['PRIMARY-08/03/2021']\n        primary.september = ['PRIMARY-09/14/2021']\n        general.november = ['GENERAL-11/02/2021']\n    [ELECTION-DATES.Y2022]\n        primary.may = ['PRIMARY-05/03/2022']\n        primary.august = ['PRIMARY-08/02/2022']\n        general.november = ['GENERAL-11/08/2022']\n\n[PARTY-AFFILIATIONS]\nC = 'Constitution Party'\nD = 'Democrat Party'\nE = 'Reform Party'\nG = 'Green Party'\nL = 'Libertarian Party'\nN = 'Natural Law Party'\nR = 'Republican Party'\nS = 'Socialist Party'\nX = 'Voted without declaring party affiliation'\n</code></pre>"},{"location":"state-fields/texas-fields/","title":"Title: Texas Fields","text":""},{"location":"state-fields/texas-fields/#overview","title":"Overview","text":"<p>Below are the fields that are available for Texas.  The fields are grouped by the section of the voter file they are in. </p>"},{"location":"state-fields/texas-fields/#texas-toml-voter-file-fields","title":"Texas TOML Voter File Fields","text":"<pre><code>[PERSON-DETAILS]\n[PERSON-DETAILS.voter-info]\nvuid = 'VUID'\nregistration_date = 'EDR'\nregistration_status = 'STATUS'\npolitical_party = ''\ndob = 'DOB'\n[PERSON-DETAILS.name]\nlast = 'LNAME'\nfirst= 'FNAME'\nmiddle = 'MNAME'\nsuffix = 'SFX'\n[PERSON-DETAILS.ADDRESS]\n[PERSON-DETAILS.ADDRESS.residence]\naddress1 = 'RESIDENTIAL_ADDRESS1'\naddress2 = 'RESIDENTIAL_SECONDARY_ADDR'\ncity = 'RESIDENTIAL_CITY'\nstate = 'RESIDENTIAL_STATE'\nzip5 = 'RESIDENTIAL_ZIP'\nzip4 = 'RESIDENTIAL_ZIP_PLUS4'\ncountry = 'RESIDENTIAL_COUNTRY'\npostal_code = 'RESIDENTIAL_POSTALCODE'\n[PERSON-DETAILS.ADDRESS.parts.residence]\nhouse_number = 'RHNUM'\nhouse_direction = 'RDESIG'\nstreet_name = 'RSTNAME'\nstreet_type = 'RSTTYPE'\nstreet_suffix = 'RSTSFX'\nunit_number = 'RUNUM'\nunit_type = 'RUTYPE'\ncity = 'RCITY'\nstate = 'TX'\nzip = 'RZIP'\nzip4 = 'RZIP4'\n[PERSON-DETAILS.ADDRESS.mail]\naddress1 = 'MADR1'\naddress2 = 'MADR2'\ncity = 'MCITY'\nstate = 'MST'\nzip5 = 'MZIP'\nzip4 = 'MZIP4'\ncountry = ''\npostal_code = ''\n[PERSON-DETAILS.VOTING-DISTRICTS]\nmunicipal_court_district = ''\ncourt_of_appeals = ''\nlocal_school_district = ''\n[PERSON-DETAILS.VOTING-DISTRICTS.precinct]\nname = ''\ncode = ''\n[PERSON-DETAILS.VOTING-DISTRICTS.city]\nname = ''\nschool_district = ''\n\n[PERSON-DETAILS.VOTING-DISTRICTS.county]\nnumber = 'COUNTY_NUMBER'\nid = 'COUNTY_ID'\ntownship = 'TOWNSHIP'\nvillage = 'VILLAGE'\nward = 'WARD'\nlibrary_district = 'LIBRARY'\ncareer_center = 'CAREER_CENTER'\ncourt_district = 'COUNTY_COURT_DISTRICT'\neducation_service_center = 'EDU_SERVICE_CENTER_DISTRICT'\nexempted_village_school_district = 'EXEMPTED_VILL_SCHOOL_DISTRICT'\n[PERSON-DETAILS.VOTING-DISTRICTS.state]\nboard_of_edu = 'STATE_BOARD_OF_EDUCATION'\nlower_chamber = 'STATE_REPRESENTATIVE_DISTRICT'\nupper_chamber = 'STATE_SENATE_DISTRICT'\n[PERSON-DETAILS.VOTING-DISTRICTS.federal]\ncongressional = 'CONGRESSIONAL_DISTRICT'\n\n[ELECTION-DATES]\n[ELECTION-DATES.Y2000]\nprimary.march = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2001]\nspecial.may = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2002]\nprimary.may = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2003]\nspecial.may = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2004]\nprimary.march = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2005]\nspecial.february = ''\nprimary.may = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2006]\nspecial.february = ''\nprimary.may = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2007]\nprimary.may = ''\nprimary.september = ''\ngeneral.november = ''\nprimary.november = ''\ngeneral.december = ''\n[ELECTION-DATES.Y2008]\nprimary.march = ''\nprimary.october = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2009]\nprimary.may = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2010]\nprimary.may = ''\nprimary.july = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2011]\nprimary.may = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2012]\nprimary.march = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2013]\nprimary.may = ''\nprimary.september = ''\nprimary.october = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2014]\nprimary.may = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2015]\nprimary.may = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2016]\nprimary.march = ''\ngeneral.june = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2017]\nprimary.may = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2018]\nprimary.may = ''\ngeneral.august = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2019]\nprimary.may = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2020]\nprimary.march = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2021]\nprimary.may = ''\nprimary.august = ''\nprimary.september = ''\ngeneral.november = ''\n[ELECTION-DATES.Y2022]\nprimary.may = ''\nprimary.august = ''\ngeneral.november = ''\n\n[PARTY-AFFILIATIONS]\nC = ''\nD = ''\nE = ''\nG = ''\nL = ''\nN = ''\nR = ''\nS = ''\nX = ''\n</code></pre>"},{"location":"validators/config/","title":"Validation Configuration Class","text":"<p>               Bases: <code>SQLModel</code></p> <p>A class that defines the configuration for a validator.</p> <p>Attributes:</p> Name Type Description <code>model_config</code> <code>ConfigDict</code> <p>A dictionary that holds the configuration settings for the model.</p> <p>The settings include:     - from_attributes (bool): If True, populates the dictionary from the model's attributes.     - populate_by_name (bool): If True, populates the dictionary by the model's name.     - str_to_upper (bool): If True, converts string values to uppercase.     - str_strip_whitespace (bool): If True, strips whitespace from string values.     - validate_default (bool): If True, validates the default values.     - arbitrary_types_allowed (bool): If True, allows arbitrary types.</p> Source code in <code>state_voterfiles/utils/pydantic_models/config.py</code> <pre><code>class ValidatorConfig(SQLModel):\n    \"\"\"\n    A class that defines the configuration for a validator.\n\n    Attributes:\n        model_config (ConfigDict): A dictionary that holds the configuration settings for the model.\n\n            The settings include:\n                - from_attributes (bool): If True, populates the dictionary from the model's attributes.\n                - populate_by_name (bool): If True, populates the dictionary by the model's name.\n                - str_to_upper (bool): If True, converts string values to uppercase.\n                - str_strip_whitespace (bool): If True, strips whitespace from string values.\n                - validate_default (bool): If True, validates the default values.\n                - arbitrary_types_allowed (bool): If True, allows arbitrary types.\n    \"\"\"\n    model_config = ConfigDict(\n        from_attributes=True,\n        populate_by_name=True,\n        str_strip_whitespace=True,\n        validate_default=True,\n        arbitrary_types_allowed=True,\n        use_enum_values=True,\n        # alias_generator=AliasGenerator(\n        #     serialization_alias=lambda field_name: to_camel(field_name)\n        # )\n    )\n</code></pre>"},{"location":"validators/record_renamer/","title":"Record Renaming Model","text":""},{"location":"validators/record_renamer/#state_voterfiles.utils.pydantic_models.rename_model.RecordRenamer","title":"<code>RecordRenamer</code>","text":"<p>               Bases: <code>ValidatorConfig</code>, <code>ABC</code></p> <p>A Pydantic model for renaming records with various date fields and settings.</p> <p>Attributes:</p> Name Type Description <code>person_dob</code> <code>Optional[str]</code> <p>The date of birth of the person.</p> <code>person_dob_yearmonth</code> <code>Optional[str]</code> <p>The year and month of the person's date of birth.</p> <code>person_dob_year</code> <code>Optional[str]</code> <p>The year of the person's date of birth.</p> <code>person_dob_month</code> <code>Optional[str]</code> <p>The month of the person's date of birth.</p> <code>person_dob_day</code> <code>Optional[str]</code> <p>The day of the person's date of birth.</p> <code>voter_registration_date</code> <code>Optional[str]</code> <p>The date of voter registration.</p> <code>raw_data</code> <code>Dict[str, Any]</code> <p>A dictionary to store raw original data before transformation.</p> <code>date_format</code> <code>Union[str, List[str]]</code> <p>The date format(s) to be used.</p> <code>settings</code> <code>Dict[str, Any]</code> <p>Additional settings for the model.</p> Source code in <code>state_voterfiles/utils/pydantic_models/rename_model.py</code> <pre><code>class RecordRenamer(ValidatorConfig, abc.ABC):\n    \"\"\"\n    A Pydantic model for renaming records with various date fields and settings.\n\n    Attributes:\n        person_dob (Optional[str]): The date of birth of the person.\n        person_dob_yearmonth (Optional[str]): The year and month of the person's date of birth.\n        person_dob_year (Optional[str]): The year of the person's date of birth.\n        person_dob_month (Optional[str]): The month of the person's date of birth.\n        person_dob_day (Optional[str]): The day of the person's date of birth.\n        voter_registration_date (Optional[str]): The date of voter registration.\n        raw_data (Dict[str, Any]): A dictionary to store raw original data before transformation.\n        date_format (Union[str, List[str]]): The date format(s) to be used.\n        settings (Dict[str, Any]): Additional settings for the model.\n    \"\"\"\n    person_dob: Annotated[Optional[str], Field(default=None)]\n    person_dob_yearmonth: Annotated[Optional[str], Field(default=None)]\n    person_dob_year: Annotated[Optional[str], Field(default=None)]\n    person_dob_month: Annotated[Optional[str], Field(default=None)]\n    person_dob_day: Annotated[Optional[str], Field(default=None)]\n    voter_registration_date: Annotated[Optional[str], Field(default=None)]\n    raw_data: Dict[str, Any] = Field(default_factory=dict)\n    date_format: Union[str, List[str]] = Field(...)\n    settings: Dict[str, Any] = Field(default_factory=dict)\n    pass\n</code></pre>"},{"location":"validators/record_renamer/#state_voterfiles.utils.pydantic_models.rename_model.VALIDATOR_FIELDS","title":"<code>VALIDATOR_FIELDS</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TomlFileFieldsABC</code></p> <p>A class to read and store field mappings from a TOML file.</p> <p>Attributes:</p> Name Type Description <code>_state</code> <code>str</code> <p>The state for which the fields are being read.</p> <code>_field_path</code> <code>Path</code> <p>The path to the TOML file containing the field mappings.</p> Source code in <code>state_voterfiles/utils/pydantic_models/rename_model.py</code> <pre><code>class VALIDATOR_FIELDS(TomlFileFieldsABC):\n    \"\"\"\n    A class to read and store field mappings from a TOML file.\n\n    Attributes:\n        _state (str): The state for which the fields are being read.\n        _field_path (Path): The path to the TOML file containing the field mappings.\n    \"\"\"\n\n    @property\n    def fields(self) -&gt; Dict[str, str]:\n        \"\"\"\n        Reads the field mappings from the TOML file.\n\n        Returns:\n            Dict[str, str]: A dictionary containing the field mappings.\n        \"\"\"\n        _field_toml = TomlReader(file=self._field_path, name=self._state.lower()).data\n        self._fields = _field_toml\n        return self._fields\n</code></pre>"},{"location":"validators/record_renamer/#state_voterfiles.utils.pydantic_models.rename_model.VALIDATOR_FIELDS.fields","title":"<code>fields: Dict[str, str]</code>  <code>property</code>","text":"<p>Reads the field mappings from the TOML file.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: A dictionary containing the field mappings.</p>"},{"location":"validators/record_renamer/#state_voterfiles.utils.pydantic_models.rename_model.create_renamed_model","title":"<code>create_renamed_model(state, field_path)</code>","text":"<p>Creates a dynamic Pydantic model for renaming records based on the provided state and field path.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>The state for which the model is being created.</p> required <code>field_path</code> <code>Path</code> <p>The path to the TOML file containing the field mappings.</p> required <p>Returns:</p> Type Description <code>Type[ValidatorConfig]</code> <p>Type[ValidatorConfig]: The dynamically created Pydantic model.</p> Source code in <code>state_voterfiles/utils/pydantic_models/rename_model.py</code> <pre><code>def create_renamed_model(state: str, field_path: Path) -&gt; Type[ValidatorConfig]:\n    \"\"\"\n    Creates a dynamic Pydantic model for renaming records based on the provided state and field path.\n\n    Args:\n        state (str): The state for which the model is being created.\n        field_path (Path): The path to the TOML file containing the field mappings.\n\n    Returns:\n        Type[ValidatorConfig]: The dynamically created Pydantic model.\n    \"\"\"\n    _fields = VALIDATOR_FIELDS(_state=state, _field_path=field_path)\n    _not_null_fields = {k: k if v == \"null\" else v for k, v in _fields.FIELDS.items()}\n\n    # _not_null_fields = {k: v for k, v in _fields.FIELDS.items() if v == \"null\"}  # Set fields that are not empty/null.\n    _validators: Dict[str, Any] = {\n        'clear_blank_strings': model_validator(mode='before')(rename_func.clear_blank_strings),\n        'create_raw_data_dict': model_validator(mode='before')(rename_func.create_raw_data_dict),\n        'check_for_address_state': model_validator(mode='after')(rename_func.check_address_has_state),\n    }  # Validators for the renaming model.\n\n    # Create the field name dictionary for the model.\n    _field_name_dict = {}\n    for k, v in _not_null_fields.items():\n        if isinstance(v, list):\n            _field_name_dict[k] = (\n                Annotated[\n                    Optional[str],\n                    Field(\n                        default=None,\n                        validation_alias=AliasChoices(*v)\n                    )\n                ]\n            )\n        else:\n            _field_name_dict[k] = (\n                Annotated[\n                    Optional[str],\n                    Field(\n                        default=None,\n                        validation_alias=AliasChoices(v)\n                    )\n                ]\n            )\n\n    # Add the date format field to the model.\n    _field_name_dict['date_format'] = (Union[str, List[str]], Field(default=_fields.FIELD_FORMATTING['date']))\n    _field_name_dict['settings'] = (dict, Field(default=_fields.SETTINGS))\n\n    # Add a field to store raw original data before transformation\n    _field_name_dict['raw_data'] = (Dict[str, Any], Field(default_factory=dict))\n\n    return create_model(\n        'RecordRenamer',\n        **_field_name_dict,\n        __base__=RecordRenamer,\n        __validators__=_validators\n    )  # Create the model.\n</code></pre>"}]}